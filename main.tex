
\usepackage[english,russian]{babel}
\usepackage{microtype}
\usepackage{unicode-math}
\usepackage{csquotes}

\usetheme{Berkeley}
\usefonttheme{professionalfonts}
%\usecolortheme[rgb={1,0.7137,0}]{stzructure}
\usepackage{libertinus}

\usepackage{graphicx}
\graphicspath{{figures/}}

\usepackage{hyperref}

\title{Код Рида-Маллера}
\author{Илья Коннов}
\institute[ВШЭ]{Факультет компьютерных наук\\Высшая Школа Экономики}
\date{\today}
\logo{\includegraphics[height=0.8cm]{cshse.pdf}}

\DeclareMathOperator{\RM}{RM}
\newcommand{\comment}[1]{\mode<article>{#1}\note[item]{#1}}

\begin{document}

\begin{frame}
    \maketitle
    
    \comment{Если вы смотрите презентацию, то на сером фоне справа видны некоторые ценные комментарии, для которых поля слайда оказались слишком узки. Если вы читаете pdf-ку, то эти комментарии уже находятся в самом подходящем для них месте в тексте. Если вы смотрите мой доклад и видите этот текст, то что-то пошло серьёзно не так. Да, у этого одного файла есть три разные версии.}
\end{frame}

\mode<article>{
	\tableofcontents
	\newpage
}

\section{Введение}
\begin{frame}{Введение}
    Описаны Дэвидом Маллером (автор идеи) и Ирвингом Ридом (автор метода декодирования) в сентябре 1954 года.
    
    Обозначаются как $\RM(r, m)$, где $r$ — ранг, а $2^m$ — длина кода. Кодирует сообщения длиной $k = \sum_{i=0}^{r} C_m^i$ при помощи $2^m$ бит.
    
    Традиционно, считается что коды работают над битами, т.е. $ℤ₂$.
\end{frame}

\begin{frame}{Булевы функции и многочлен Жегалкина}
    Всякую булеву функцию можно записать при помощи таблицы истинности
    \[
        \begin{array}{cc | c}
            x & y & f(x, y) \\\hline
            0 & 0 & 1 \\
            0 & 1 & 0 \\
            1 & 0 & 0 \\
            1 & 1 & 0
        \end{array}
    \]
    
    И при помощи многочлена Жегалкина:
    \[
        f(x, y) = xy + x + y + 1
    \]
\end{frame}

\begin{frame}{Многочлены Жегалкина}
    В общем случае, многочлены будут иметь следующий вид:
    \[
        f(x_1, x_2, …, x_m) = \sum_{S ⊆ \{1, …, m\}} c_S \prod_{i ∈ S} x_i
    \]

    Например, для $m = 2$: $ f(x_1, x_2) = c_1 \cdot x_1x_2 + c_2 \cdot x_1 + c_3 \cdot x_2 + c_4\cdot1$
    
    Всего $n = 2^m$ коэффициентов для описания каждой функции.
\end{frame}

\begin{frame}{Функции небольшой степени}
    Рассмотрим функции, степень многочленов которых не больше $r$:
    \[
        \{ f(x_1, x_2, …, x_m) \mid \deg f ≤ r \}
    \]
    
    Каждую можно записать следующим образом:
    \[
        f(x_1, x_2, …, x_m) = \sum_{\substack{S ⊆ \{1, …, m\}\\|S| ≤ r}} c_S \prod_{i ∈ S} x_i
    \]
    В каждом произведении используется не больше $r$ переменных.
    
    \comment{Замечу, что при $S = \emptyset$, мы считаем, что $\prod_{i∈S} x_i = 1$, таким образом всегда появляется свободный член.}

    Сколько тогда всего коэффициентов используется?
    \[
        k = C_m^0 + C_m^2 + … + C_m^r = \sum_{i=0}^r C_m^i
    \]
    
    \comment{
        Если говорить несколько проще, то для составления многочленов мы сложим сначала одночлены ($x + y + z$), затем произведения одночленов ($xy + yz + xz$) и т.д. вплоть до $r$ множителей. Тогда легко видеть, почему $k$ именно такое: мы складываем все возможные перестановки сначала для 0 переменных, потом для одной, двух, и так до всех $r$
    }
\end{frame}

\section{Кодирование}
\begin{frame}{Идея кодирования}
    Пусть каждое сообщение (длины $k$) — коэффициенты некоторого многочлена от $m$ переменных степени не больше $r$.
    
    Тогда мы можем его представить при помощи $2^n$ бит, подставив все возможные комбинации переменных (ведь рассматриваем многочлены над $ℤ₂$).
    
    Таким образом получим таблицу истинности, из которой позднее сможем восстановить исходный многочлен, а вместе с ним и сообщение.
\end{frame}

\begin{frame}{Пример}
    \begin{itemize}
        \item $r = 1$ (степень многочлена), $m = 2$ (переменных).\\Это $\RM(1, 2)$. \\
        \item Тогда наш многочлен: $f(x, y) = c_1 x + c_2 y + c_3$.
        \item Сообщение: $\mathtt{101}$, тогда $f(x, y) = x + 0 + 1$.
        \item Подставим всевозможные комбинации:
            \[
                \begin{array}{cc | c}
                    x & y & f(x, y) \\\hline
                    0 & 0 & 1 \\
                    0 & 1 & 1 \\
                    1 & 0 & 0 \\
                    1 & 1 & 0
                \end{array}
            \].
        \item Получили код: $\mathtt{1100}$.
    \end{itemize}
\end{frame}

\section{Свойства кода}
\begin{frame}{Линейность}
    \begin{displayquote}
        Линейный (блоковый) код — такой код, что множество его кодовых слов образует $k$-мерное линейное подпространство в $n$-мерном линейном пространстве, изоморфное пространству $k$-битных векторов.
    \end{displayquote}
    Слова — 
\end{frame}

\section{Декодирование}
\begin{frame}{Потерь нет}
    
\end{frame}

\end{document}
